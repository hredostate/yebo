import React, { useState, useEffect, useRef } from 'react';
import ReactDOM from 'react-dom/client';
import { supa as supabase } from '../offline/client';
import type { Student, GradingScheme, SchoolConfig, ReportCardConfig } from '../types';
import Spinner from './common/Spinner';
import { CloseIcon, DownloadIcon, CheckCircleIcon, AlertCircleIcon } from './common/icons';
import html2canvas from 'html2canvas';
import jsPDF from 'jspdf';
import JSZip from 'jszip';
import { UnifiedReportCard } from './reports/UnifiedReportCard';
import { buildUnifiedReportData } from '../utils/buildUnifiedReportData';
import type { WatermarkType } from '../types/reportCardPrint';

interface BulkReportCardGeneratorProps {
  classId: number;
  className: string;
  termId: number;
  termName: string;
  students: Student[];
  onClose: () => void;
  addToast: (message: string, type?: 'success' | 'error' | 'info') => void;
  schoolConfig: SchoolConfig | null;
  gradingSchemes: GradingScheme[];
}

interface StudentWithDebt extends Student {
  hasDebt: boolean;
  outstandingAmount: number;
  averageScore?: number;
  reportExists: boolean;
}

interface ReportSubject {
  subjectName: string;
  totalScore?: number;
  grade?: string;
  remark?: string;
  componentScores?: Record<string, number>;
  subjectPosition?: number | null;
}

interface ReportData {
  student: {
    fullName: string;
    className: string;
  };
  term: {
    sessionLabel: string;
    termLabel: string;
  };
  subjects: ReportSubject[];
  schoolConfig: {
    school_name?: string;
    display_name?: string;
    address?: string;
    motto?: string;
    logo_url?: string;
  };
  summary?: {
    positionInArm?: number | string;
    totalStudentsInArm?: number | string;
    gpaAverage?: number | string;
    campusPercentile?: number | null;
  };
  comments?: {
    teacher?: string;
    principal?: string;
  };
  attendance?: {
    present: number;
    absent: number;
    late: number;
    excused: number;
    unexcused: number;
    total: number;
    rate: number;
  };
}

const BulkReportCardGenerator: React.FC<BulkReportCardGeneratorProps> = ({
  classId,
  className,
  termId,
  termName,
  students,
  onClose,
  addToast,
  schoolConfig,
  gradingSchemes,
}) => {
  const [studentsWithDebt, setStudentsWithDebt] = useState<StudentWithDebt[]>([]);
  const [selectedStudentIds, setSelectedStudentIds] = useState<Set<number>>(new Set());
  const [isLoading, setIsLoading] = useState(true);
  const [isGenerating, setIsGenerating] = useState(false);
  const [generationProgress, setGenerationProgress] = useState<{ current: number; total: number } | null>(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [wizardStep, setWizardStep] = useState<1 | 2 | 3>(1);
  const [outputMode, setOutputMode] = useState<'zip' | 'combined'>('zip');
  const [includeCoverSheet, setIncludeCoverSheet] = useState(true);
  const [includeCsvSummary, setIncludeCsvSummary] = useState(false);
  const [watermarkChoice, setWatermarkChoice] = useState<'NONE' | 'DRAFT' | 'FINAL'>('NONE');
  const [templateChoice, setTemplateChoice] = useState<'classic' | 'modern' | 'pastel' | 'professional'>('classic');
  const [previewing, setPreviewing] = useState(false);
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [jobStatus, setJobStatus] = useState<'idle' | 'queued' | 'generating' | 'packaging' | 'completed' | 'failed'>('idle');
  const [jobReport, setJobReport] = useState<{ successes: string[]; failures: { name: string; reason: string }[] }>({ successes: [], failures: [] });
  const [samplePreviewIds, setSamplePreviewIds] = useState<Set<number>>(new Set());
  const reportContainerRef = useRef<HTMLDivElement>(null);

  // Sharing state
  const [showSharingModal, setShowSharingModal] = useState(false);
  const [isSharingLinks, setIsSharingLinks] = useState(false);
  const [shareExpiryHours, setShareExpiryHours] = useState(72);
  const [shareResults, setShareResults] = useState<Array<{ studentName: string; link?: string; error?: string }>>([]);

  // Utility function to sanitize strings for safe HTML rendering and filenames
  const sanitizeString = (str: string): string => {
    return str
      .replace(/[<>'"&]/g, (char) => {
        // HTML entity encoding for basic XSS prevention
        const entities: Record<string, string> = {
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;',
          '&': '&amp;'
        };
        return entities[char] || char;
      })
      .replace(/[^\w\s.\-]/g, '_') // Allow periods and hyphens for filenames
      .trim();
  };

  useEffect(() => {
    fetchStudentData();
  }, [classId, termId, students]);

  useEffect(() => {
    return () => {
      if (previewUrl) {
        URL.revokeObjectURL(previewUrl);
      }
    };
  }, [previewUrl]);

  const fetchStudentData = async () => {
    setIsLoading(true);
    try {
      // Get students in this class
      if (!supabase) {
        throw new Error('Database connection not available');
      }

      const { data: enrollments, error: enrollError } = await supabase
        .from('academic_class_students')
        .select('student_id')
        .eq('academic_class_id', classId);

      if (enrollError) throw enrollError;

      const enrolledStudentIds = enrollments?.map(e => e.student_id) || [];
      const classStudents = students.filter(s => enrolledStudentIds.includes(s.id));

      // Fetch invoices for these students in this term
      const { data: invoices, error: invoiceError } = await supabase
        .from('student_invoices')
        .select('student_id, total_amount, amount_paid, status')
        .eq('term_id', termId)
        .in('student_id', enrolledStudentIds);

      if (invoiceError) throw invoiceError;

      // Fetch student term reports to get average scores
      const { data: reports, error: reportError } = await supabase
        .from('student_term_reports')
        .select('student_id, average_score')
        .eq('term_id', termId)
        .in('student_id', enrolledStudentIds);

      if (reportError) throw reportError;

      // Calculate debt status for each student
      const studentsData: StudentWithDebt[] = classStudents.map(student => {
        const studentInvoices = invoices?.filter(inv => inv.student_id === student.id) || [];
        const totalOwed = studentInvoices.reduce((sum, inv) => sum + (inv.total_amount - inv.amount_paid), 0);
        const hasUnpaidInvoices = studentInvoices.some(inv => inv.status !== 'Paid');
        const hasDebt = totalOwed > 0 || hasUnpaidInvoices;

        const studentReport = reports?.find(r => r.student_id === student.id);
        
        return {
          ...student,
          hasDebt,
          outstandingAmount: totalOwed,
          averageScore: studentReport?.average_score,
          reportExists: !!studentReport,
        };
      });

      // Sort by name
      studentsData.sort((a, b) => a.name.localeCompare(b.name));

      setStudentsWithDebt(studentsData);

      // Auto-select students without debt and with reports
      const autoSelectIds = new Set(
        studentsData
          .filter(s => !s.hasDebt && s.reportExists)
          .map(s => s.id)
      );
      setSelectedStudentIds(autoSelectIds);

    } catch (error: any) {
      addToast(`Error loading student data: ${error.message}`, 'error');
      console.error('Error fetching student data:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleSelectAll = () => {
    const eligibleStudents = studentsWithDebt.filter(s => !s.hasDebt && s.reportExists);
    setSelectedStudentIds(new Set(eligibleStudents.map(s => s.id)));
  };

  const handleDeselectAll = () => {
    setSelectedStudentIds(new Set());
  };

  const handleToggleStudent = (studentId: number) => {
    const newSelected = new Set(selectedStudentIds);
    if (newSelected.has(studentId)) {
      newSelected.delete(studentId);
    } else {
      newSelected.add(studentId);
    }
    setSelectedStudentIds(newSelected);
  };

  const togglePreviewStudent = (studentId: number) => {
    const updated = new Set(samplePreviewIds);
    if (updated.has(studentId)) {
      updated.delete(studentId);
    } else {
      if (updated.size >= 3) {
        addToast('Preview is limited to 3 students at a time.', 'info');
        return;
      }
      updated.add(studentId);
    }
    setSamplePreviewIds(updated);
  };

  const handlePreviewSample = async () => {
    const targetId = samplePreviewIds.values().next().value || selectedStudentIds.values().next().value;
    const targetStudent = studentsWithDebt.find((s) => s.id === targetId) || studentsWithDebt[0];

    if (!targetStudent) {
      addToast('Select at least one student to preview.', 'error');
      return;
    }

    setPreviewing(true);
    if (previewUrl) {
      URL.revokeObjectURL(previewUrl);
      setPreviewUrl(null);
    }

    const result = await generateStudentReportPDF(targetStudent, templateChoice, watermarkChoice === 'NONE' ? undefined : watermarkChoice);
    if (result) {
      const url = URL.createObjectURL(result.blob);
      setPreviewUrl(url);
      setWizardStep(2);
      addToast('Preview ready. Open the PDF to inspect margins and layout.', 'info');
    }
    setPreviewing(false);
  };

  const appendCanvasToPdf = (pdf: jsPDF, canvas: HTMLCanvasElement, startOnNewPage = false) => {
    const pageWidth = 210;
    const pageHeight = 297;
    const margin = 6;
    const safeWidth = pageWidth - margin * 2;
    const safeHeight = pageHeight - margin * 2;

    const imgData = canvas.toDataURL('image/png');
    const imgWidth = safeWidth;
    const imgHeight = (canvas.height * imgWidth) / canvas.width;

    if (startOnNewPage) {
      pdf.addPage('a4', 'portrait');
    }

    let heightLeft = imgHeight;
    let position = margin;

    pdf.addImage(imgData, 'PNG', margin, position, imgWidth, imgHeight);
    heightLeft -= safeHeight;

    while (heightLeft > 0) {
      position = margin - (imgHeight - heightLeft);
      pdf.addPage('a4', 'portrait');
      pdf.addImage(imgData, 'PNG', margin, position, imgWidth, imgHeight);
      heightLeft -= safeHeight;
    }

    return Math.max(1, Math.ceil(imgHeight / safeHeight));
  };

  const renderReportCanvas = async (student: StudentWithDebt, layoutOverride?: string, watermarkText?: string) => {
    try {
      const { data: reportData, error: reportError } = await supabase.rpc('get_student_term_report_details', {
        p_student_id: student.id,
        p_term_id: termId,
      });

      if (reportError || !reportData) {
        console.error(`Error fetching report for student ${student.name}:`, reportError);
        addToast(`Failed to fetch report for ${student.name}`, 'error');
        return null;
      }

      let classReportConfig = null;
      let assessmentComponents = null;

      const { data: enrollment } = await supabase
        .from('academic_class_students')
        .select('academic_class_id')
        .eq('student_id', student.id)
        .eq('enrolled_term_id', termId)
        .maybeSingle();

      if (enrollment?.academic_class_id) {
        const { data: classData } = await supabase
          .from('academic_classes')
          .select('report_config, assessment_structure_id')
          .eq('id', enrollment.academic_class_id)
          .maybeSingle();

        if (classData?.report_config) {
          classReportConfig = classData.report_config;
        }

        if (classData?.assessment_structure_id) {
          const { data: structure } = await supabase
            .from('assessment_structures')
            .select('components')
            .eq('id', classData.assessment_structure_id)
            .maybeSingle();

          if (structure?.components) {
            assessmentComponents = structure.components;
          }
        }
      }

      // Override layout if specified
      if (layoutOverride && classReportConfig) {
        classReportConfig = { ...classReportConfig, layout: layoutOverride };
      } else if (layoutOverride && !classReportConfig) {
        classReportConfig = { layout: layoutOverride };
      }

      // Normalize data to UnifiedReportCardData format
      const unifiedData = buildUnifiedReportData(
        reportData,
        schoolConfig,
        student.admission_number || 'N/A',
        assessmentComponents,
        classReportConfig ? { report_config: classReportConfig } : null
      );

      // Create temporary container off-screen
      const tempContainer = document.createElement('div');
      tempContainer.style.position = 'absolute';
      tempContainer.style.left = '-9999px';
      tempContainer.style.top = '0';
      tempContainer.style.width = '794px'; // A4 width at 96dpi
      tempContainer.style.height = '1123px'; // A4 height at 96dpi
      document.body.appendChild(tempContainer);

      // Render UnifiedReportCard component
      const root = ReactDOM.createRoot(tempContainer);
      const watermark: WatermarkType = watermarkText === 'DRAFT' ? 'DRAFT' : watermarkText === 'FINAL' ? 'FINAL' : 'NONE';
      
      root.render(<UnifiedReportCard data={unifiedData} watermark={watermark} />);

      // Wait for render to complete
      await new Promise(resolve => setTimeout(resolve, 200));

      // Capture as canvas
      const canvas = await html2canvas(tempContainer, {
        scale: 2,
        useCORS: true,
        logging: false,
        backgroundColor: '#ffffff',
        width: 794,
        height: 1123,
        windowWidth: 794,
        windowHeight: 1123,
      });

      // Cleanup
      root.unmount();
      document.body.removeChild(tempContainer);
      
      return canvas;
    } catch (error) {
      console.error(`Error preparing canvas for ${student.name}:`, error);
      return null;
    }
  };

  const generateStudentReportPDF = async (student: StudentWithDebt, layoutOverride?: string, watermarkText?: string): Promise<{ blob: Blob; pagesAdded: number } | null> => {
    try {
      const canvas = await renderReportCanvas(student, layoutOverride, watermarkText);
      if (!canvas) return null;

      const pdf = new jsPDF({
        orientation: 'portrait',
        unit: 'mm',
        format: 'a4',
      });

      const pagesAdded = appendCanvasToPdf(pdf, canvas, false);
      return { blob: pdf.output('blob'), pagesAdded };
    } catch (error) {
      console.error(`Error generating PDF for student ${student.name}:`, error);
      return null;
    }
  };

  // Helper to format ordinal suffix (1st, 2nd, 3rd)
